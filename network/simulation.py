from __future__ import annotations

import asyncio
import random
import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from enum import Enum, auto
from typing import Optional, Tuple


class NetworkEvent(Enum):
    """High-level events generated by the network simulator."""

    LATENCY = auto()
    DROP = auto()
    FAILURE = auto()


@dataclass
class NetworkConditions:
    """Configurable network fault parameters."""

    loss_rate: float = 0.8
    latency_range_ms: Tuple[float, float] = (0.0, 0.0)
    failure_probability: float = 0.0
    failure_duration_range_s: Tuple[float, float] = (5.0, 15.0)
    recovery_check_interval_s: float = 1.0
    random_seed: Optional[int] = None

    def __post_init__(self) -> None:
        self.loss_rate = _clamp_probability(self.loss_rate, "loss_rate")
        self.failure_probability = _clamp_probability(self.failure_probability, "failure_probability")
        if self.latency_range_ms[0] > self.latency_range_ms[1]:
            raise ValueError("latency_range_ms must be (min, max)")
        if self.failure_duration_range_s[0] > self.failure_duration_range_s[1]:
            raise ValueError("failure_duration_range_s must be (min, max)")
        if self.recovery_check_interval_s <= 0:
            raise ValueError("recovery_check_interval_s must be > 0")


def _clamp_probability(value: float, name: str) -> float:
    if not 0.0 <= value <= 1.0:
        raise ValueError(f"{name} must be between 0 and 1 inclusive")
    return value


@dataclass
class NetworkSimulator:
    """Helper to inject latency, drops and failures into protocol flows."""

    conditions: NetworkConditions
    rng: random.Random = field(default_factory=random.Random)
    _failure_until: Optional[datetime] = None

    def __post_init__(self) -> None:
        if self.conditions.random_seed is not None:
            self.rng.seed(self.conditions.random_seed)

    def _now(self) -> datetime:
        return datetime.now(timezone.utc)

    def _schedule_new_failure(self) -> None:
        min_s, max_s = self.conditions.failure_duration_range_s
        duration = self.rng.uniform(min_s, max_s)
        self._failure_until = self._now() + timedelta(seconds=duration)

    def _maybe_toggle_failure(self) -> bool:
        """Return True if the network is currently in a failure state."""
        if self._failure_until is None:
            if self.rng.random() < self.conditions.failure_probability:
                self._schedule_new_failure()
                return True
            return False

        if self._now() >= self._failure_until:
            self._failure_until = None
            return False
        return True

    def current_failure_remaining(self) -> Optional[float]:
        """Return remaining failure duration in seconds, if any."""
        if self._failure_until is None:
            return None
        delta = self._failure_until - self._now()
        return max(0.0, delta.total_seconds())

    def should_drop(self) -> bool:
        """Determine whether the next packet should be dropped."""
        return self.rng.random() < self.conditions.loss_rate

    def latency_delay(self) -> float:
        """Return latency in seconds to wait."""
        min_ms, max_ms = self.conditions.latency_range_ms
        if max_ms <= 0:
            return 0.0
        millis = self.rng.uniform(min_ms, max_ms)
        return max(0.0, millis / 1000.0)

    async def apply_async(self) -> Optional[NetworkEvent]:
        """Inject asynchronous latency and failure, returning the triggered event."""
        if self._maybe_toggle_failure():
            await asyncio.sleep(self.conditions.recovery_check_interval_s)
            return NetworkEvent.FAILURE

        delay = self.latency_delay()
        if delay > 0:
            await asyncio.sleep(delay)
            return NetworkEvent.LATENCY
        return None

    def apply_sync(self) -> Optional[NetworkEvent]:
        """Inject synchronous latency and failure."""
        if self._maybe_toggle_failure():
            time.sleep(self.conditions.recovery_check_interval_s)
            return NetworkEvent.FAILURE

        delay = self.latency_delay()
        if delay > 0:
            time.sleep(delay)
            return NetworkEvent.LATENCY
        return None

    def describe(self) -> str:
        """Return a human-readable summary of the current configuration."""
        min_ms, max_ms = self.conditions.latency_range_ms
        min_fail, max_fail = self.conditions.failure_duration_range_s
        parts = [
            f"loss={self.conditions.loss_rate:.0%}",
            f"latency={min_ms:.0f}-{max_ms:.0f}ms",
            f"fail_prob={self.conditions.failure_probability:.0%}",
            f"fail_duration={min_fail:.1f}-{max_fail:.1f}s",
        ]
        return ", ".join(parts)

